class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, root, key):
        """Insert key into subtree rooted at root and return the (possibly new) root."""
        if root is None:
            return Node(key)
        if key < root.key:
            root.left = self.insert(root.left, key)
        elif key > root.key:
            root.right = self.insert(root.right, key)
        # if equal, we do nothing (no duplicates). Could also handle duplicates differently.
        return root

    def inorder(self, root):
        if root:
            self.inorder(root.left)
            print(root.key, end=' ')
            self.inorder(root.right)

    def preorder(self, root):
        if root:
            print(root.key, end=' ')
            self.preorder(root.left)
            self.preorder(root.right)

    def postorder(self, root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            print(root.key, end=' ')

    def search(self, root, key):
        """Return the node if found, otherwise None."""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        else:
            return self.search(root.right, key)

    def min_value_node(self, node):
        """Return node with minimum key in subtree rooted at node."""
        current = node
        while current.left is not None:
            current = current.left
        return current

    def delete(self, root, key):
        """Delete key from subtree rooted at root and return new root."""
        if root is None:
            return root
        if key < root.key:
            root.left = self.delete(root.left, key)
        elif key > root.key:
            root.right = self.delete(root.right, key)
        else:
            # Case 1: no child or one child
            if root.left is None:
                return root.right
            elif root.right is None:
                return root.left
            # Case 2: two children -> replace with inorder successor (min in right subtree)
            temp = self.min_value_node(root.right)
            root.key = temp.key
            root.right = self.delete(root.right, temp.key)
        return root

    def menu(self):
        while True:
            print("\n--- Menu ---")
            print("1. Insert (multiple keys allowed, space-separated)")
            print("2. Inorder")
            print("3. Preorder")
            print("4. Postorder")
            print("5. Search")
            print("6. Delete")
            print("7. Exit")

            try:
                choice = int(input("Enter your choice: "))
            except ValueError:
                print("Please enter a valid integer choice.")
                continue

            if choice == 1:
                keys = input("Enter keys to insert (space-separated): ").split()
                for k in keys:
                    try:
                        key = int(k)
                    except ValueError:
                        print(f"Skipping invalid key: {k}")
                        continue
                    self.root = self.insert(self.root, key)
                print("Insertion complete.")

            elif choice == 2:
                print("Inorder Traversal:")
                if self.root is None:
                    print("(tree is empty)")
                else:
                    self.inorder(self.root)
                    print()  # newline

            elif choice == 3:
                print("Preorder Traversal:")
                if self.root is None:
                    print("(tree is empty)")
                else:
                    self.preorder(self.root)
                    print()

            elif choice == 4:
                print("Postorder Traversal:")
                if self.root is None:
                    print("(tree is empty)")
                else:
                    self.postorder(self.root)
                    print()

            elif choice == 5:
                try:
                    key = int(input("Enter key to search: "))
                except ValueError:
                    print("Invalid key.")
                    continue
                result = self.search(self.root, key)
                if result:
                    print(f" Key {key} found.")
                else:
                    print(f" Key {key} not found.")

            elif choice == 6:
                try:
                    key = int(input("Enter key to delete: "))
                except ValueError:
                    print("Invalid key.")
                    continue
                self.root = self.delete(self.root, key)
                print(f"If present, key {key} has been deleted. Current inorder:")
                if self.root:
                    self.inorder(self.root)
                else:
                    print("(tree is empty)")
                print()

            elif choice == 7:
                print("Exiting.")
                break

            else:
                print("Invalid option. Try again!")


if __name__ == "__main__":
    tree = BST()
    tree.menu()
